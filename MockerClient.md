# MockerClient

Configures the Vue store and create vuex modules for each service.

### Usage

Configure the store

```js
// store/index.js
import Vue from 'vue'
import Vuex, { Store } from 'vuex'
import axios from 'axios'
import { MockerClient } from '@valtech-br/simple-mocker/client'
import { MockerClient } from '@valtech-br/simple-mocker' // for webpack 4.0

// Configure the client
const mocker = new MockerClient({
  services: {
    users: {}
  },
  transport: axios // Pass axios as transport (required)
})

// Generate modules
const mockerModules = mocker.createVuexModules()

// Add the Vuex plugin.
Vue.use(Vuex)

export default new Store({
  modules: {
    // Import modules
    ...mockerModules
  }
})

```

Now at the component:

```vue
<script>
import { mapState, mapActions } from 'vuex'

export default {
  name: 'users',
  created() {
    this.findItems({ limit: 6, skip: 0 })
  },
  computed: {
    ...mapState('users', ['items'])
  },
  methods: {
    ...mapActions('users', ['findItems'])
  }
}
</script>

<template>
  <div :class="['users']">
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>Name</th>
          <th>E-mail</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="user in items" :key="user.id">
          <td>{{ user.id }}</td>
          <td>{{ user.name }}</td>
          <td>{{ user.email }}</td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

```

### Basic service store

When you run `mocker.createVuexModules()` an array of vuex modules is created for each service registered in the service namespace.

#### Service State

```js
{
  items: [],
  total: 0,
  isFindPending: false,
  isGetPending: false,
  isCreatePending: false,
  isPatchPending: false,
  isDeletePending: false
}
```
- `items {Array}` - items fetched from get or `find` methods
- `total {Number}` - total number of items generated by the server
- `isFindPending {Boolean}` - `true` if there's a pending `find` method. `false` if not.
- `isGetPending {Boolean}` - `true` if there's a pending `get` method. `false` if not.
- `isCreatePending {Boolean}` - `true` if there's a pending `create` method. `false` if not.
- `isPatchPending {Boolean}` - `true` if there's a pending `patch` method. `false` if not.
- `isDeletePending {Boolean}` - `true` if there's a pending `delete` method. `false` if not.

#### Service Actions

This are the methods exposed by **MockerService** class to the store.

#### `createItem(item)`
Create new mocked data in the the server
- `item {Object}` - Properties for the new item to be created

```js
store.dispatch('users/createItem', {
  email: 'user@email.com',
  name: 'User Name',
  password: 'secret'
})
// returns the created item with it's id

// or using vuex helper methods

methods: {
  ...mapActions('users', ['createItem']),
  createUser () {
    this.createItem({
      email: 'user@email.com',
      name: 'User Name',
      password: 'secret'
    })
  }
}
```

#### `patchItem({ id, params })`
Patch mocked data in the the server
- `arg {Object}`
  - `id {Number}` - id of the item to be patched
  - `params {Object}` - properties to be updated

```js
store.dispatch('users/patchItem', {
  id: 3,
  params: {
    password: 'ultra_secret'
  }
})
// returns the patched item

// or using vuex helper methods

methods: {
  ...mapActions('users', ['patchItem']),
  patchUser () {
    this.patchItem({
      id: 3,
      params: {
        password: 'ultra_secret'
      }
    })
  }
}
```

#### `deleteItem(id)`
Delete mocked data in the the server
- `id {Number}` - id of the item to be deleted

```js
store.dispatch('users/deleteItem', 3)
// returns the deleted item

// or using vuex helper methods

methods: {
  ...mapActions('users', ['delteItem']),
  delteUser () {
    this.delteItem(3)
  }
}
```

#### `findItems({ limit, skip })`
Get mocked data from the the server
- `pagination {Object}`
  - `limit {Number}` - how many items you want on your request. defaults to `4`
  - `skip {Number}` - how many items to skip. defaults to `0`

```js
store.dispatch('users/findItems', { limit: 10, skip: 10 })
// returns 10 items from {id} 11 to 21

// or using vuex helper methods

methods: {
  ...mapActions('users', ['findItems']),
  findUsers () {
    this.findItems({ limit: 10, skip: 10 })
  }
}
```

#### `getItem(id)`
Get a single mocked item from the the server
- `id {Number}` - `id` of the item you want. defaults to `1`

```js
store.dispatch('users/getItem', 4)
// returns data from {user} with {id} 4

// or using vuex helper methods

methods: {
  ...mapActions('users', ['getItem']),
  findUsers () {
    this.getItem(4)
  }
}
```

#### Service Getters

Getters available in the service module.

#### `findInStore({ limit, skip }) {Function}` 
Helper function to get an array of items from the store
- `pagination {Object}`
  - `limit {Number}` - how many items to return from the store. defaults to `4`
  - `skip {Number}` - how many items to skip. defaults to `0`
```js
store.getters['users/findInStore']({ limit: 10, skip: 10 })
// returns 10 items from {id} 11 to 21 from the store

// or using vuex helper methods

computed: {
  ...mapGetters('users', ['findInStore']),
  usersList () {
    return this.findInStore({ limit: 10, skip: 10 })
  }
}
```

#### `getById(id) {Function}`
Helper function to get a single item from the store
- `id {Number}` - **id** of the item to be returned. if this item does not exist in store it will return `undefined`
```js
store.getters['users/getById'](4)
// returns data from {user} with {id} 4 from the store

// or using vuex helper methods

computed: {
  ...mapGetters('users', ['getById']),
  currentUser () {
    return this.getById(4)
  }
}
```

#### Service Mutations

The mutations are used internally by the service actions, but you can see them bellow.

```js
{
  ADD_ITEM_TO_STORE (state, item) {
    const exists = !!state.items
      .map((it, i) => {
        return Object.assign({}, it, { index: i })
      })
      .filter(i => i.id === item.id)[0]
    if (!exists) {
      state.items.push(item)
    } else {
      state.items = state.items.splice(exists.index, 1, item)
    }
  },
  UPDATE_TOTAL (state, total) {
    state.total = total
  },
  IS_CREATE_PENDING (state) {
    state.isCreatePending = true
  },
  CREATE_FINISHED (state) {
    state.isCreatePending = false
  },
  IS_PATCH_PENDING (state) {
    state.isPatchPending = true
  },
  PATCH_FINISHED (state) {
    state.isPatchPending = false
  },
  IS_DELETE_PENDING (state) {
    state.isDeletePending = true
  },
  DELETE_FINISHED (state) {
    state.isDeletePending = false
  },
  IS_FIND_PENDING (state) {
    state.isFindPending = true
  },
  FIND_FINISHED (state) {
    state.isFindPending = false
  },
  IS_GET_PENDING (state) {
    state.isGetPending = true
  },
  GET_FINISHED (state) {
    state.isGetPending = false
  }
}
```

## API


#### Arguments (constructor)


| name | type | description | default |
|------|------|-------------|---------|
| host | `string` | host where the server will be created | `localhost`
| port | `string` `number` | port where the server will be listening | `3001`
| services | `object` | object where the `key` is the name of the service and the `value` is a empty object | `{}`
| transport | `axios` | transport to be used to make the server call, only `axios` is suported at the moment | `undefined`

## Issues

#### 1) Transport with other libraries (or the fetch api)
At the moment there is only support for axios, but this idea of injecting the transport on creation is to be expanded to other possible libraries, including the window fetch api

## Possibilities

#### 1) Create a query system
We could create a form of querying to be able to filter items by fields to mimic search funcionality.

~~#### 2) Create other methods like, `create` and `patch`~~